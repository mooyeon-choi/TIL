

# 알고리즘 - Day 1

* IM 단계 :
  * 배열, 리스트
  * 반복문(for, while) 분기문(if-else)
  * 수식(연산자 + 피연산자)
* Ad 단계 :
  * 완전 탐색
    * 백트래킹 - BFS, DFS
* 사용 가능 : append, [ for in ], len()
* 사용 불가 : 외에 다른 메소드, 슬라이싱



### APS 기본 8개 장

* 배열 1(Array 1)
* 배열 2(Array 2)
* 문자열
* Stack 1
* Stack 2
* Queue
* 연결리스트
* Tree



### APS 응용

* 그래프
* 완전탐색
* 분할정복
* 백트래킹



## 1. 배열 1(Array 1)

* 알고리즘
* 배열
* 완전검색
* 그리디 (Greedy Algorithm)
* 버블 정렬 (Bubble Sort)
* 카운팅 정렬 (Counting Sort)



### 1. 알고리즘

> 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

* 어떠한 문제를 해결하기 위한 절차

* 알고리즘을 표현하는 방법

  * 슈더코드

    ![슈더코드](./image/슈더코드.png)

  * 순서도

    ![순서도](./image/순서도.png)

* 좋은 알고리즘의 조건

  * 정확성 : 얼마나 정확하게 동작하는가
  * 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  * 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
  * 단순성 : 얼마나 단순한가
  * 최적성 : 더 이상 개선할 여지없이 최적화되었는가



#### 시간 복잡도

> 알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다.

* 실제 걸리는 시간을 측정

* **실행되는 명령문의 개수를 계산**

  ```python
  def func(n):
      # 명령문 - 1번
      for i in range(n):
          # 명령문 - n번
          for j in range(i, n):
              # 명령문 - n * (n + 1) / 2
  ```

  * 총 실행 횟수 : `n * (n + 1) / 2 + n + 1`
  * n이 커질수록 가장 높은 차수의 값에만 영향을 받는다 -> 이를 이용해 근사치를 구할 수 있음

* 시간 복잡도 표기법

  * 빅-오 표기법(O( ))
  * 오메가 표기법(Ω( ))
  * 세타 표기법(θ( ))



##### 빅-오(O) 표기법

* 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

* 계수(Coefficient)는 생략하여 표시

  ![big-O](./image/big-O.png)

  * `O(1)` : 상수로 표시한 경우 n에 상관없이 일정한 시간이 걸림

* 빅-오 시간 복잡도

  ![big-O_time](./image/big-O_time.png)
  
  * `p` : 시간 복잡도 낮은 쉬운 문제들
  * `np` : 시간 복잡도가 높은 어려운 문제들



### 2. 배열

* 배열이란 무엇인가?
  * 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조



#### 정렬

* 정렬의 종류
  * 버블 정렬 (Bubble Sort)
  * 카운팅 정렬 (Counting Sort)
  * 선택 정렬 (Selection Sort)
  * 퀵 정렬 (Quick Sort)
  * 삽입 정렬 (Insertion Sort)
  * 병합 정렬 (Merge Sort)

##### 버블 정렬 (Bubble Sort)

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
>
> 가장 큰 값을 맨뒤로 보내준다

* 정렬 과정

  > 시간복잡도 O(n<sup>2</sup>)

  * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
  * 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
  * 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

* 버블 정렬 알고리즘

  ```python
  def BubbleSort(a): # 정렬할 List
      for i in range(len(a)-1, 0, -1): # 범위의 끝 위치
          for j in range(0, i):
              if a[j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j]
  ```



##### 카운팅 정렬 (Counting Sort)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
>
> 시간 복잡도 O(n + k) : n은 리스트 길이, k는 정수의 최대값

* 제한 사항

  * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

    각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.

  * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

* 카운팅 정렬 알고리즘

  * Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.

    ```python
    arr = [0, 4, 1, 3, 1, 2, 4, 1]
    # 양의 정수, 최대값을 알아야 된다.
    # 최대값 = 4
    cnt = [0] * 5 # 배열의 인덱스 n-1 = 4
    for var in arr:
        cnt[var] += 1
    print(cnt)
    ```
  
  * 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
  
    ```python
    # 누적 빈도수 계산
    for i in range(1, len(cnt)):
        cnt[i] = cnt[i - 1] + cnt[i]
    print(cnt)
    ```
  
    ![counting](./image/counting.png)
  
  * 해당 counts 인덱스의 값을 1씩 감소시키면서 값을 읽어와 그 위치에 저장해준다.
  
  * 최종 알고리즘
  
    ```python
    def Counting_Sort(A, B, k):
        # A [1..n] -- 입력 배열(1 to k)
        # B [1..n] -- 정렬된 배열.
        # C [1..k] -- 카운트 배열.
        C = [0] * k
        for i in range(0, len(B)):
            C[A[i]] += 1
        for i in range(1, len(C)):
            C[i] += C[i-1]
        for i in range(len(B)-1, -1, -1):
            B[C[A[i]]-1] = A[i]
            C[A[i]] -= 1
    ```
  



### 3. 완전 검색 (Exaustibe Search)

`Brute-force` 혹은 `generate-and-test` 기법이라고도 불린다.

> 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.

* 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.

* 일반적으로 경우의 수가 상대적으로 적을 때 유용하다.
  * 결정 문제
  
  * 최적화 문제
    * 최적해를 구하는 문제
    * 최소 혹은 최대가 되는 경우를 찾는다.
    * 모든 후보해(가능한 경우)를 조사한다.
    * 순열(n!), 조합, 부분집합(2<sup>n</sup>), ...
    
    
    
  * 완전 탐색을 효율적으로 하는 방법
  
    * 탐색기반 - 백트래킹 +(가지치기)
  
    * 문제간의 관계(재귀적관계) 동적 계획법
  
      
  
  * 완전 탐색을 하지 않고 최적화 문제를 해결하는 방법
  
    * 탐욕 기법 (특정한 경우에만 사용가능)
  
    
  
* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적다.

* 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.



### 4. 탐욕(Greedy) 알고리즘

> 최적해를 구하는데 사용되는 근시안적인 방법

* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각된느 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
* 일반적으로, 머릿속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy 접근이 된다.